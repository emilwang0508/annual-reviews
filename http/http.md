## 001.HTTP报文结构是怎么样的

## 002.如何理解HTTP的请求方法

### 有哪些请求
http/1.1规定了以下请求方法：
+ GET: 通常用来获取资源
+ HEAD：获取资源的元信息
+ POST：提交数据，即上传数据
+ PUT：修改数据
+ DELETE：删除资源（几乎用不到）
+ CONNECT：建立连接隧道，用于代理服务器
+ OPTIONS：列出可对资源实行的请求方法，用来跨域请求
+ TRACE：追踪请求-响应的传输路径
  
### GET和POST有什么区别
+ 从缓存的角度，GET请求会被浏览器主动缓存下来，留下历史记录，而POST不会。
+ 从编码的角度，GET只能进行URL编码，只能接受ASCII字符，而POST没有限制
+ 从参数的角度，GET一般只放在URL中，因此不安全，POST放在请求体中，更适合传输敏感信息
+ 从幂等性的角度，GET是幂等的，而POST不是（幂等表示执行相同的操作，结果也是相同的）
+ 从TCP的角度，GET请求会把请求报文一次性发出去，而POST会分为两个TCP数据包，首先发header部分，如果服务器响应100(continue)，然后发body部分（Firefox的post请求只会发一个TCP包）

### URI编码
URI 只能使用ASCII, ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。
URI 引入了编码机制，将所有非 ASCII 码字符和界定符转为十六进制字节值，然后在前面加个%。
如，空格被转义成了%20，三元被转义成了%E4%B8%89%E5%85%83。

### 004: 如何理解 HTTP 状态码？
RFC规定HTTP的状态码为三位数，被分为五类：
+ 1xx: 表示目前是协议处理的中间状态，还需要后续操作。
+ 2xx: 表示成功状态
+ 3xx: 重定向状态，资源位置发生变动，需要重新请求。
+ 4xx: 请求报文有误。
+ 5xx: 服务端发生错误。

#### 具体的状态码
##### 1xx
101 Switch Protocols，在HTTP升级为Websocket的时候，如果服务器同意变更，就会发送状态码101；

##### 2xx
200 OK是成功状态码，通常在响应体中放有数据。
204 No Content含义与200相同，但响应头后没有body数据
206 Partial Content，表示部门内容，它的使用场景为HTTP分块下载和断点续传，当然也会带上相应的响应头字段Content-Range

##### 3xx
301 永久重定向，对应着302 Found，即临时重定向。
比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回301，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。如果只是暂时，那么直接返回302即可，浏览器并不会做缓存优化。
304 Not Modified 当协商缓存命中时会返回这个状态码。

##### 4xx
400 笼统的提示一下错误
403 Forbidden 服务器进制访问，比如法律禁止，信息敏感，没有权限
404 Not Found 资源未找到，表示没在服务器上找到相应的资源
405 Method Not Allowed：请求方法不被服务器端允许
406 Not Acceptable：资源无法满足客户端的条件
408 Request Timeout：请求超时
409 多个请求发生了冲突
413 请求体的数据过大
414 请求行里的URI太大
429 客户端发送的请求太多
431 请求头的字段太多

##### 5xx
500 笼统的提示服务器出错
501 表示客户端请求的功能还不支持
502 Bad Gateway：服务器自身是正常的，但访问的时候出错了，具体错误也不知道。
503 表示服务器当前很忙，暂时无法响应服务

### 005: 简要概括一下 HTTP 的特点？HTTP 有哪些缺点？

#### HTTP特点
##### 无状态
在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么就是其缺点。但一些应用只是为了获取一些数据，不需要保存上下文信息，无状态反而减少了网络开销，就是其优点

##### 明文传输
协议里的报文不使用二进制数据，而是文本形式。WIFI陷阱就是利用HTTP明文传输的缺点，诱导连热点，然后疯狂抓取你所有的流量，从而拿到你的敏感信息。

##### 队头阻塞问题
当http开启长连接时，共用一个TCP链接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态


### 006: 对 Accept 系列字段了解多少？

#### 数据格式
HTTP从MIME type取了一部分来标记报文body部分的数据类型，类型体现在Content—type这个字段
具体而言，这两个字段的取值可以分为下面几类
+ text: text/html, text/plain, text/css
+ image: image/gif, image/jpeg, image/png等
+ audio/video: audio/mpeg, video/mp4等
+ application: application/json, application/javascript, application/pdf...

#### 压缩方式
发送方是Content-Encoding，接受方是Accept-Encoding
+ gzip: 当今最流行的压缩格式
+ deflate: 另外一种著名的压缩格式
+ br: 专门为HTTP发明的压缩算法

#### 支持语言
```nginx
// 发送端
Content-Language: zh-CN, zh, en
// 接收端
Accept-Language: zh-CN, zh, en
```

#### 字符集
```
// 发送端
Content-Type: text/html; charset=utf-8
// 接收端
Accept-Charset: charset=utf-8
```

### 010: HTTP1.1 如何解决 HTTP 的队头阻塞问题？

#### 并发连接

#### 域名分片


### 013: 如何理解 HTTP 缓存及缓存代理？
HTTP缓存：首先通过Cache-control验证强缓存是否可用
+ 如果强缓存可用，直接使用
+ 否则进入协商缓存，即发送HTTP请求，服务器通过请求头中的If-modified-Since或者If-None-Match这些条件请求字段检查资源是否更新
  + 若资源更新，返回资源和200状态码
  + 否则，返回304，告诉浏览器直接从缓存获取资源

### 017: HTTP/2 有哪些改进？
+ 头部压缩
HPACK算法：
  + 首先是在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，在传输的时候对于之前出现过的值，只需要把索引传给对方即可
  + 其次是对于整数和字符串进行哈夫曼编码，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的索引序列，可以达到非常高的压缩率。

+ 多路复用
  + HTTP队头阻塞问题: 其根本原因在于HTTP基于请求-响应的模型，在同一个TCP长连接中，前面的请求没有得到响应，后面的请求就会被阻塞。
  + 二进制分帧：原来Headers + Body的报文格式如今被拆分成了一个个二进制的帧，用Headers帧存放头部字段，Data帧存放请求体数据。服务器看到的不再是一个个完整的HTTP请求报文，而是一堆乱序的二进制帧。通信双方都可以给对方发送二进制帧，这种二进制帧的双向传输的序列，也叫做流（stream）。HTTP/2用流来在一个TCP链接上进行多个帧的通信，这就是多路复用。
  
+ 设置请求优先级
  + 所谓的乱序，是指不同ID的Stream是乱序的，但是同一个Stream ID的帧一定是按顺序传输的。二进制帧到达后对方将Stream ID相同的二进制帧组装成完整的请求报文和响应报文。二进制帧其他的一些字段，实现了优先级和流量控制等功能。
  
+ 服务器推送
  + 在HTTP/2，服务器不再是完全被动地接受请求，响应请求，它也能新建stream来给客户端发送信息，当TCP链接建立后，比如浏览器请求一个HTML文件，服务器就可以在返回HTML的基础上，将HTML中引用到的其他资源一起返回给客户端，减少客户端的等待。

### 018: HTTP/2 中的二进制帧是如何设计的？

#### 帧结构
每个帧分为帧头和帧体。先是三个字节的帧长度，这个长度表示的是帧体的长度。
然后是帧的类型，大概可以分为数据帧和控制帧两种。数据帧用来存放HTTP报文，控制帧用来管理流的传输。
接下来是一个字节的帧标志，里面一共有8个标志位，常用的有END_HEADERS表示头数据结束，END_STREAM表示单方向数据发送结束。
后四个字节是Stream ID，也就是流表示符，有了它。接收方就能从乱序的二进制帧中选择出ID相同的帧，按顺序组装成请求/响应报文。

#### 流的状态变化
最开始两者都是空闲状态，当客户端发送Headers帧之后，开始分配Stream ID，此时客户端的流打开；服务端接收之后服务端的流也打开，两端就可以互相传递数据帧和控制帧了。

当客户端要关闭时，向服务端发送END_STREAM帧，进入半关闭状态，这个时候客户端只能接收，不能发送数据。

服务器接收到了这个END_STREAM帧之后也进入了半关闭状态，此时服务器只能发送不能接收数据。随后服务器也可以向用户端发送END_STREAM帧，表示数据发送完毕，双方进入关闭状态。

如果下次要开启新的流，STREAM ID需要自增，直到上限为止，达到上限后开启一个新的TCP链接重头计数。由于流ID字段长度为4个字节，最高位又被保留，因此范围是0-2的31次方，大约21亿个.

#### 流的特性
+ 并发性：一个HTTP/2连接上可以同时发送多个帧，这个也是实现多路复用的基础。
+ 自增性：流ID是不可重用的，而是会被按顺序递增，达到上限后又开启新的TCP连接，重新计数
+ 双向性：客户端和服务端都可以创建流，互不干扰，双方都可以作为发送发或接收方
+ 可以设置优先级：让服务器先处理重要资源，优化用户体验。

### 019: 浏览器缓存

浏览器的缓存过程：强缓存，协商缓存
浏览器缓存位置一般分为四类：Service Worker->Memory Cache->Disk Cache->Push Cache

#### 强缓存
当我们第一次进入页面，请求服务器，然后服务器进行应答，浏览器会根据response Header来判断是否对资源进行缓存，如果响应头中expires、pragma或者cache-control字段，代表这是强缓存，浏览器会把资源存在memory cache或disk cache中。

第二次请求时，浏览器判断请求参数，如果符合强制缓存条件就直接返回状态码200，从本地缓存中拿数据。否则把响应参数存在request header请求头中，看是否符合协商缓存，符合则返回状态码304，不符合则服务器会返回全新资源