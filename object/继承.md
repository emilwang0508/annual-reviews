## 原型链继承
```js
function Parent () {
    this.name = 'parentName'
}

Parent.prototype.getName = function () {
    console.log(this.name)
}

function Child() {}
// const child = new Child();
// child.__proto__ = Child.prototype
// Child.prototype.__proto__ === Parent.prototype
Child.prototype = new Parent();
Child.prototype.constructor = Child;

const child1 = new Child()
child1.getName()
```
### 隐含的问题
1. 如果有属性是引用类型的，一旦某个实例修改了这个属性，所有的实例都会受到影响
2. 创建Child实例的时候，无法传参

## 构造函数继承
想办法把Parent上的属性和方法，添加/复制到Child？而不是都存在原型对象/Parent上，防止被实例共享
<!-- 解决第一个问题 -->
```js
function Parent () {
    this.actions = ['ear', 'sleep']
    this.name = 'parentName';
}
function Child () {
    Parent.call(this)
}
const c1 = new Child()
const c2 = new Child()

c1.actions.pop()
console.log(c1.actions)
console.log(c1.actions)
```
<!-- 解决第二个问题 -->
```js
function Parent (name, actions) {
    this.actions = actions
    this.name = name;
}
function Child (id, name, actions) {
    // Parent.call(this, name, actions)
    Parent.apply(this, Array.prototype.slice.call(arguments, 1))
    this.id = id;
}
```
### 隐含的问题
1. 属性或方法被继承的话，只能在构造函数中定义。如果方法在构造函数内定义了，那么每次创建一次实例都会占用一块内存

## 组合继承
原型链继承，实现了基本的继承，方法存在prototype上，子类可以直接调用，但是引用类型的属性会被所有实例共享，并且不能传参
构造函数继承，首先解决了原型链继承的两个问题，带来了一个新的问题，构造函数内重复创建方法，导致内存占用过多

### 实现
```js
function Parent (name, actions) {
    this.actions = ['ear', 'sleep']
    this.name = 'parentName';
}
Parent.prototype.eat = function () {
    console.log(`${this.name} - eat`)
}
function Child (id) {
    Parent.apply(this, Array.from(arguments).slice(1))
    this.id = id
}
Child.prototype = new Parent()
Child.prototype.constructor = Child;

let c1 = new Child(1, 'c1', ['哈哈'])
let c2 = new Child(2, 'c2', ['嘻嘻'])

c1.eat()
c2.eat()
```