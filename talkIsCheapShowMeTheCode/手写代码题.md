## 1. 手写一个new操作符
<!-- http://blog.ifyouseewendy.com/blog/2017/07/03/review-you-dont-know-js-this-and-object-prototypes/#what-happened-when-we-callnew- -->
## new操作符做了哪些事情？
1. 它创建了一个全新的对象
2. 它会被执行[[Prototype]]（也就是__proto__）链接
3. 它使this指向新创建的对象
4. 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。
5. 如果函数没有返回对象类型Object（包含Function，Array，Date，RegExg，Error），那么new表达式中的函数调用将返回该对象引用。
```js
function New(fn) {
    // 1. 它创建了一个全新的对象
    var res = {};
    // 2. 它会被执行[[Prototype]]（也就是__proto__）链接
    if (fn.prototype !== null) {
        res.__proto__ = fn.prototype
    }
    // 3. 它使this指向新创建的对象
    var ret = fn.apply(res, Array.prototype.slice.call(arguments, 1))

    // 4. 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。
    // 5. 如果函数没有返回对象类型Object（包含Function，Array，Date，RegExg，Error），那么new表达式中的函数调用将返回该对象引用。
    if ((typeof ret === 'object' || typeof ret === 'function' && ret !== null)) {
        return ret
    }
    return res
}
function A (a, b) {
    this.a = a;
    this.b = b;    
}
A.prototype.run = () => {
    return this.a + this.b;
}

var obj1 = New(A, 1, 2)
var obj2 = new A(1, 2)
```

## 实现一个JSON.stringify
- JSON.stringify(value[, replacer, [, space]])
- Boolean | Number | String 类型会自动转换成对应的原始值.
- undefined、任意函数以及symbol，会被忽略（出现在非数组对象的属性值中时），或者被转换成null（出现在数组中时）。
- 不可枚举的属性会被忽略
- 如果一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略。
```js
function JSON_Stringify(obj) {
    let type = typeof obj
    if (type !== 'object') {
        if (/string|undefined|function/.test(type)) {
            obj = '"' + obj + '"';
        }
        return String(obj)
    } else {
        let json = [],
            isArr = Array.isArray(obj)
        
        for(let k in obj) {
            let v = obj[k],
                type = typeof v;
            
            if (/string|undefined|function/.test(type)) {
                v = '"' + v + '"';
            } else if (type === 'object') {
                v = JSON_Stringify(v)
            }
            json.push((isArr ? "" : '"' + k + '":') + String(v))
        }
        return (isArr ? "[" : "{") + String(json) + (isArr ? "]" : "}")
    }
}

JSON_Stringify({x: 5})
JSON_Stringify([1, "false", false])
JSON_Stringify({b: undefined})
```

## 实现一个JSON.parse

```js
// eval
function jsonParse(opt) {
    return eval('(' + opt + ')');
}
// Function
var func = new Function(arg1, arg2, ..., functionBody);
var jsonStr = '{ "age": 20, "name": "jack" }'
var json = (new Function('return ' + jsonStr))();
```

## 实现一个call或apply方法
- call语法：

- fun.call(thisArg, arg1, arg2, ...)，调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。

- apply语法：

- func.apply(thisArg, [argsArray])，调用一个函数，以及作为一个数组（或类似数组对象）提供的参数。
### call实现
```js
// call 实现
Function.prototype._call = function (context = window) { // 如果不传入参数，默认指向为 window
    // 指定this到函数并传入给定参数执行函数
    context.fn = this;
    let args = [...arguments].slice(1)
    // 将函数设为对象的属性
    let result = context.fn(...args)
    // 执行&删除这个函数
    delete context.fn;
    return result;
}

let foo = {
    value: 1
}
function bar(name, age) {
    console.log(name)
    console.log(age)
    console.log(this.value);
}
bar.call2(foo, 'black', '18') // black 18 1

```
### apply实现
```js
// apply实现
Function.prototype._apply = function(context = window) {
    context.fn = this
    let result;
    // 判断是否有第二个参数
    if (arguments[1]){
        result = context.fn(...arguments[1])
    } else {
        result = context.fn()
    }
    delete context.fn
    return result
}
```
### bind实现
- bind()方法：会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN )
```js
// bind实现
Function.prototype._bind = function (context) {
    if (typeof this !== 'function') {
        throw Error("not a function")
    }
    // 若没问题参数类型则从这开始写
    let fn = this;
        args = [...arguments].slice(1);
    
    let resFn = function () {
        return fn.apply(this instanceof resFn ? this : context,args.concat(...arguments))
    }

    function tmp() {}
    tmp.prototype = this.prototype
    resFn.prototype = new tmp()

    return resFn
}
```

## 实现一个继承
### 寄生组合式继承
- 一般只建议写这种，因为其他方式的继承会在一次实例中调用两次父类的构造函数或其他缺点
```js
// 核心实现是：用一个F空的构造函数去取代执行了Parent这个构造函数
function Parent(name) {
    this.name = name
}
Parent.prototype.sayName = function () {
    console.log('parent name: ', this.name)
}
function Child (name, parentName) {
    Parent.call(this, parentName)
    this.name = name
}
function create(proto) {
    function F() {}
    F.prototype = proto;
    return new F();
}
Child.prototype = create(Parent.prototype)
Child.prototype.sayName = function () {
    console.log('child name:', this.name)
}
Child.prototype.constructor = Child;

var parent = new Parent('father')
parent.sayName(); // parent name: father

var child = new Child('son', 'father')
```

## 函数柯里化
- 什么是柯里化 
- 在计算机科学中，柯里化是把接受多个参数的函数变成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术。函数柯里化的主要作用和特点就是参数复用、提前返回和延迟执行。

```js
// 柯里化通用版
function curry(fn, args) {
    var length = fn.length
    var args = args || []
    return function () {
        let newArgs = args.concat(Array.prototype.slice.call(arguments));
        if (newArgs.length < length) {
            return curry.call(this, fn, newArgs)
        } else {
            return fn.apply(this, newArgs)
        }
    }
}

function multiFn(a,b,c) {
    return a*b*c
}

var multi = curry(multiFn)

multi(2)(3)(4);
multi(2,3,4);
multi(2)(3,4);
multi(2,3)(4);
```

```js
// es6版柯里化
const curry = (fn, arr = []) => (...args) => (
    arg => arg.length === fn.length
        ? fn(...arg)
        : curry(fn, arg)
)([...arr, ...args])

let curryTest = curry((a,b,c,d) => a+b+c+d)
```

## 手写一个Promise/A+规范
### Promise/A+规范
- 三种状态pending | fulfilled(resolved) | rejected
- 当处于pending状态的时候，可以转移到fullfilled(resolved)或者rejected状态
- 当处于fulfilled状态或者rejected状态的时候，就不可变
- 必须有一个then异步执行方法，then接受两个参数且必须返回一个Promise

```js
function myPromise(executor) {
    let self = this

    self.status = 'pending'
    self.value = undefined;
    self.reason = undefined;
    function resolve(value) {
        if(self.status === 'pending') {
            self.value = value
            self.status = 'resolved'
        }
    }
    function reject(reason) {
        if (self.status === 'pending') {
            self.reason = reason
            self.status = 'rejected'
        }
    }
    // 捕获异常
    try {
        executor(resolve, reject)
    } catch(e) {
        reject(e)
    }
}
myPromise.prototype.then = function(onFulfilled, onRejected) {
    let self = this
    switch(self.status) {
        case 'resolved':
            onFulfilled(self.value)
            break;
        case 'rejected':
            onRejected(self.reason)
            break;
        default:
    }
}
```
```js
// 专业版
const PENDING = 'pending',
      FULFILLED = 'fulfilled',
      REJECTED = 'rejected;

function MyPromise (executor) {
    let context = this
    context.status = PENDING; // 初始状态
    context.value = undefined;
    context.reason = undefined;
    context.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数
    context.onRejectedCallbacks = []; // 存储rejected状态对应的onReject函数

    function resolve (value) {
        if (value instanceof Promise) {
            return value.then(resolve, reject)
        }
        queueMicrotask(() => {
            // 调用resolve回调时对应onFulfilled函数
            if (context.status = PENDING) {
                // 只能由pending状态=>fulfilled状态(避免调用多次resolve reject)
                context.status = FULFILLED;
                context.value = value;s
                context.onFulfilledCallbacks.forEach(cb => cb(context.values))
            }
        })
    }

    function reject (reason) {
        queueMicrotask(() => {
            if (context.status = PENDING) {
                context.status = REJECTED;
                context.reason = reason;
                context.onRejectedCallbacks.forEach(cb => cb(context.reason))
            }
        })
    }

    try{
        executor(resolve, reject)
    } catch (e) {
        reject(e)
    }
}

MyPromise.prototype.then = function(onFulfilled, onRejected) {
    const that = this
    let newPromise

    // 处理参数默认值,保证参数后续能够继续执行
    onFulfilled = typeof onFulfilled === "function" ? onFulfilled : value => value;
    onRejected = typeof onRejected === "function" ? onRejected : reason => reason;

    if (that.status === FULFILLED) {
        return newPromise = new MyPromise((resolve, reject) => {
            queueMicrotask(() => {
                try{
                    let x = onFulfilled(that.value)
                    resolvePromise(newPromise, x, resolve, reject);//   新的promise resolve 上一个onFulfilled的返回值
                } catch (e) {
                    reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected);
                }
            })
        })
    }

    if (that.status === REJECTED) {
        return newPromise = new MyPromise((resolve, reject) => {
            queueMicrotask(() => {
                try{
                    let x = onRejected(that.reason)
                    resolvePromise(newPromise, x, resolve, reject);//   新的promise resolve 上一个onFulfilled的返回值
                } catch (e) {
                    reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected);
                }
            })
        })
    }

    if (that.status === PENDING) {
        return newPromise = new MyPromise((resolve, reject) => {
            that.onFulfilledCallbacks.push((value) => {
                try {
                    let x = onFulfilled(value)
                    resolvePromise(newPromise, x, resolve, reject)
                } catch (e) {
                    reject(e)
                }
            })
            that.onRejectedCallbacks.push((reason) => {
                try {
                    let x = onRejected(reason)
                    resolvePromise(newPromise, x, resolve, reject)
                } catch (e) {
                    reject(e)
                }
            })
        })
    }
}

[[resolvePromose]]
resolvePromise(promise2, x, resolve, reject) {
    const that = this
    if (promise2 === x) {
        return reject(new TypeError('The promise and the return value as the same'))
    }

    if (x instanceof MyPromise) {
        // 如果x是promise，那么让新的Promise接手x的状态
        // 继续执行x，如果执行的时候又拿到一个y，那么继续解析y
        queueMicrotask(() => {
            x.then((y) => {
                that.resolvePromise(promise2, y, resolve, reject)
            })
        })

    } else if (typeof x === 'object' || typeof x === 'function'){
        if (x == null) {
            return resolve(x)
        }
        let then = null;

        try {
            then = x.then
        } catch (e) {
            return reject(e)
        }

        if (typeof then === 'function') {
            let called = false;
            try {
                then.call(
                    x, 
                    (y) => {
                        if (called) return
                        called = true
                        that.resolvePromise(promise2, y, resolve, reject)
                    },
                    (r) => {
                        if (called) return
                        called = true
                        reject(r)
                    }
                )
            } catch(e) {
                if (called) return
                reject(e)
            }
        } else {
            resolve(x)
        }
    } else {
        resolve(x)
    }
}
```

## 防抖与节流
### 防抖函数debounce
```js
function debounce(fn, wait = 50, immediate){
    let timer;
    return function () {
        if (immediate) {
            fn.apply(this, arguments)
        }
        if (timer) clearTimeout(timer)
        timer = setTimeout(() => {
            fn.apply(this, arguments)
        }, wait)
    }
}
```

### 节流函数throttle
```js
function throttle(fn, await) {
    let prev = new Date()
    return function () {
        const args = arguments;
        const now = new Date()
        if (now - prev > await){
            fn.apply(this, args)
            prev = new Date()
        }
    }
}

```

## Js深拷贝

```js
// 乞丐版
var newObj = JSON.parse(JSON.stringify(someObj));
```
```js
// 面试够用版
function deepClone(obj) {
    if (obj == null) { return null } 
    if (typeof obj === 'object') {
        // 复杂类型
        let result = obj.constructor === Array : [] : {}
        for (let i in obj) {
            result[i] = typeof obj[i] === 'object' ? deepClone(result[i]) : obj[i]
        }
    } else {
        let result = obj
    }
    return result
}
```

## 实现一个instanceOf

```js
function instanceOf(left, right) {
    let proto = left.__proto__
    let prototype = right.prototype

    while(true) {
        if (proto === null) return false
        if (proto === prototype) return true
        proto = proto.__proto__
    }
}
```