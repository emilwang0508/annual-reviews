## 1. 手写一个new操作符
<!-- http://blog.ifyouseewendy.com/blog/2017/07/03/review-you-dont-know-js-this-and-object-prototypes/#what-happened-when-we-callnew- -->
### new操作符做了哪些事情？
1. 它创建了一个全新的对象
2. 它会被执行[[Prototype]]（也就是__proto__）链接
3. 它使this指向新创建的对象
4. 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。
5. 如果函数没有返回对象类型Object（包含Function，Array，Date，RegExg，Error），那么new表达式中的函数调用将返回该对象引用。
```js
function New(fn) {
    // 1. 它创建了一个全新的对象
    var res = {};
    // 2. 它会被执行[[Prototype]]（也就是__proto__）链接
    if (fn.prototype !== null) {
        res.__proto__ = fn.prototype
    }
    // 3. 它使this指向新创建的对象
    var ret = fn.apply(res, Array.prototype.slice.call(arguments, 1))

    // 4. 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。
    // 5. 如果函数没有返回对象类型Object（包含Function，Array，Date，RegExg，Error），那么new表达式中的函数调用将返回该对象引用。
    if ((typeof ret === 'object' || typeof ret === 'function' && ret !== null)) {
        return ret
    }
    return res
}
function A (a, b) {
    this.a = a;
    this.b = b;    
}
A.prototype.run = () => {
    return this.a + this.b;
}

var obj1 = New(A, 1, 2)
var obj2 = new A(1, 2)
```

## 实现一个JSON.stringify
- JSON.stringify(value[, replacer, [, space]])
- Boolean | Number | String 类型会自动转换成对应的原始值.
- undefined、任意函数以及symbol，会被忽略（出现在非数组对象的属性值中时），或者被转换成null（出现在数组中时）。
- 不可枚举的属性会被忽略
- 如果一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略。
```js
function JSON_Stringify(obj) {
    let type = typeof obj
    if (type !== 'object') {
        if (/string|undefined|function/.test(type)) {
            obj = '"' + obj + '"';
        }
        return String(obj)
    } else {
        let json = [],
            isArr = Array.isArray(obj)
        
        for(let k in obj) {
            let v = obj[k],
                type = typeof v;
            
            if (/string|undefined|function/.test(type)) {
                v = '"' + v + '"';
            } else if (type === 'object') {
                v = JSON_Stringify(v)
            }
            json.push((isArr ? "" : '"' + k + '":') + String(v))
        }
        return (isArr ? "[" : "{") + String(json) + (isArr ? "]" : "}")
    }
}

JSON_Stringify({x: 5})
JSON_Stringify([1, "false", false])
JSON_Stringify({b: undefined})
```

## 实现一个JSON.parse

```js
// eval
function jsonParse(opt) {
    return eval('(' + opt + ')');
}
// Function
var func = new Function(arg1, arg2, ..., functionBody);
var jsonStr = '{ "age": 20, "name": "jack" }'
var json = (new Function('return ' + jsonStr))();
```

## 实现一个call或apply方法
- call语法：

- fun.call(thisArg, arg1, arg2, ...)，调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。

- apply语法：

- func.apply(thisArg, [argsArray])，调用一个函数，以及作为一个数组（或类似数组对象）提供的参数。
### call实现
```js
// call 实现
Function.prototype._call = function (context = window) { // 如果不传入参数，默认指向为 window
    // 指定this到函数并传入给定参数执行函数
    context.fn = this;
    let args = [...arguments].slice(1)
    // 将函数设为对象的属性
    let result = context.fn(...args)
    // 执行&删除这个函数
    delete context.fn;
    return result;
}

let foo = {
    value: 1
}
function bar(name, age) {
    console.log(name)
    console.log(age)
    console.log(this.value);
}
bar.call2(foo, 'black', '18') // black 18 1

```
### apply实现
```js
// apply实现
Function.prototype._apply = function(context = window) {
    context.fn = this
    let result;
    // 判断是否有第二个参数
    if (arguments[1]){
        result = context.fn(...arguments[1])
    } else {
        result = context.fn()
    }
    delete context.fn
    return result
}
```
### bind实现
- bind()方法：会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN )
```js
// bind实现
Function.prototype._bind = function (context) {
    if (typeof this !== 'function') {
        throw Error("not a function")
    }
    // 若没问题参数类型则从这开始写
    let fn = this;
        args = [...arguments].slice(1);
    
    let resFn = function () {
        return fn.apply(this instanceof resFn ? this : context,args.concat(...arguments))
    }

    function tmp() {}
    tmp.prototype = this.prototype
    resFn.prototype = new tmp()

    return resFn
}
```

## 实现一个继承
### 寄生组合式继承
- 一般只建议写这种，因为其他方式的继承会在一次实例中调用两次父类的构造函数或其他缺点
```js
// 核心实现是：用一个F空的构造函数去取代执行了Parent这个构造函数
function Parent(name) {
    this.name = name
}
Parent.prototype.sayName = function () {
    console.log('parent name: ', this.name)
}
function Child (name, parentName) {
    Parent.call(this, parentName)
    this.name = name
}
function create(proto) {
    function F() {}
    F.prototype = proto;
    return new F();
}
Child.prototype = create(Parent.prototype)
Child.prototype.sayName = function () {
    console.log('child name:', this.name)
}
Child.prototype.constructor = Child;

var parent = new Parent('father')
parent.sayName(); // parent name: father

var child = new Child('son', 'father')
```

## 函数柯里化
- 什么是柯里化 
- 在计算机科学中，柯里化是把接受多个参数的函数变成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术。函数柯里化的主要作用和特点就是参数复用、提前返回和延迟执行。

```js
// 柯里化通用版
function curry(fn, args) {
    var length = fn.length
    var args = args || []
    return function () {
        let newArgs = args.concat(Array.prototype.slice.call(arguments));
        if (newArgs.length < length) {
            return curry.call(this, fn, newArgs)
        } else {
            return fn.apply(this, newArgs)
        }
    }
}

function multiFn(a,b,c) {
    return a*b*c
}

var multi = curry(multiFn)

multi(2)(3)(4);
multi(2,3,4);
multi(2)(3,4);
multi(2,3)(4);
```

```js
// es6版柯里化
const curry = (fn, arr = []) => (...args) => (
    arg => arg.length === fn.length
        ? fn(...arg)
        : curry(fn, arg)
)([...arr, ...args])

let curryTest = curry((a,b,c,d) => a+b+c+d)
```

## 手写一个Promise/A+规范
### Promise/A+规范
- 三种状态pending | fulfilled(resolved) | rejected
- 当处于pending状态的时候，可以转移到fullfilled(resolved)或者rejected状态
- 当处于fulfilled状态或者rejected状态的时候，就不可变
- 必须有一个then异步执行方法，then接受两个参数且必须返回一个Promise

```js
function myPromise(executor) {
    let self = this

    self.status = 'pending'
    self.value = undefined;
    self.reason = undefined;
    function resolve(value) {
        if(self.status === 'pending') {
            self.value = value
            self.status = 'resolved'
        }
    }
    function reject(reason) {
        if (self.status === 'pending') {
            self.reason = reason
            self.status = 'rejected'
        }
    }
    // 捕获异常
    try {
        executor(resolve, reject)
    } catch(e) {
        reject(e)
    }
}
myPromise.prototype.then = function(onFulfilled, onRejected) {
    let self = this
    switch(self.status) {
        case 'resolved':
            onFulfilled(self.value)
            break;
        case 'rejected':
            onRejected(self.reason)
            break;
        default:
    }
}
```
```js
// 专业版
const PENDING = 'pending',
      FULFILLED = 'fulfilled',
      REJECTED = 'rejected;

function MyPromise (executor) {
    let context = this
    context.status = PENDING; // 初始状态
    context.value = undefined;
    context.reason = undefined;
    context.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数
    context.onRejectedCallbacks = []; // 存储rejected状态对应的onReject函数

    function resolve (value) {
        if (value instanceof Promise) {
            return value.then(resolve, reject)
        }
        queueMicrotask(() => {
            // 调用resolve回调时对应onFulfilled函数
            if (context.status = PENDING) {
                // 只能由pending状态=>fulfilled状态(避免调用多次resolve reject)
                context.status = FULFILLED;
                context.value = value;s
                context.onFulfilledCallbacks.forEach(cb => cb(context.values))
            }
        })
    }

    function reject (reason) {
        queueMicrotask(() => {
            if (context.status = PENDING) {
                context.status = REJECTED;
                context.reason = reason;
                context.onRejectedCallbacks.forEach(cb => cb(context.reason))
            }
        })
    }

    try{
        executor(resolve, reject)
    } catch (e) {
        reject(e)
    }
}

MyPromise.prototype.then = function(onFulfilled, onRejected) {
    const that = this
    let newPromise

    // 处理参数默认值,保证参数后续能够继续执行
    onFulfilled = typeof onFulfilled === "function" ? onFulfilled : value => value;
    onRejected = typeof onRejected === "function" ? onRejected : reason => reason;

    if (that.status === FULFILLED) {
        return newPromise = new MyPromise((resolve, reject) => {
            queueMicrotask(() => {
                try{
                    let x = onFulfilled(that.value)
                    resolvePromise(newPromise, x, resolve, reject);//   新的promise resolve 上一个onFulfilled的返回值
                } catch (e) {
                    reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected);
                }
            })
        })
    }

    if (that.status === REJECTED) {
        return newPromise = new MyPromise((resolve, reject) => {
            queueMicrotask(() => {
                try{
                    let x = onRejected(that.reason)
                    resolvePromise(newPromise, x, resolve, reject);//   新的promise resolve 上一个onFulfilled的返回值
                } catch (e) {
                    reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected);
                }
            })
        })
    }

    if (that.status === PENDING) {
        return newPromise = new MyPromise((resolve, reject) => {
            that.onFulfilledCallbacks.push((value) => {
                try {
                    let x = onFulfilled(value)
                    resolvePromise(newPromise, x, resolve, reject)
                } catch (e) {
                    reject(e)
                }
            })
            that.onRejectedCallbacks.push((reason) => {
                try {
                    let x = onRejected(reason)
                    resolvePromise(newPromise, x, resolve, reject)
                } catch (e) {
                    reject(e)
                }
            })
        })
    }
}

[[resolvePromose]]
resolvePromise(promise2, x, resolve, reject) {
    const that = this
    if (promise2 === x) {
        return reject(new TypeError('The promise and the return value as the same'))
    }

    if (x instanceof MyPromise) {
        // 如果x是promise，那么让新的Promise接手x的状态
        // 继续执行x，如果执行的时候又拿到一个y，那么继续解析y
        queueMicrotask(() => {
            x.then((y) => {
                that.resolvePromise(promise2, y, resolve, reject)
            })
        })

    } else if (typeof x === 'object' || typeof x === 'function'){
        if (x == null) {
            return resolve(x)
        }
        let then = null;

        try {
            then = x.then
        } catch (e) {
            return reject(e)
        }

        if (typeof then === 'function') {
            let called = false;
            try {
                then.call(
                    x, 
                    (y) => {
                        if (called) return
                        called = true
                        that.resolvePromise(promise2, y, resolve, reject)
                    },
                    (r) => {
                        if (called) return
                        called = true
                        reject(r)
                    }
                )
            } catch(e) {
                if (called) return
                reject(e)
            }
        } else {
            resolve(x)
        }
    } else {
        resolve(x)
    }
}
```

## 防抖与节流
### 防抖函数debounce
```js
function debounce(fn, wait = 50, immediate){
    let timer;
    return function () {
        if (immediate) {
            fn.apply(this, arguments)
        }
        if (timer) clearTimeout(timer)
        timer = setTimeout(() => {
            fn.apply(this, arguments)
        }, wait)
    }
}
```

### 节流函数throttle
```js
function throttle(fn, await) {
    let prev = new Date()
    return function () {
        const args = arguments;
        const now = new Date()
        if (now - prev > await){
            fn.apply(this, args)
            prev = new Date()
        }
    }
}

```

## Js深拷贝

```js
// 乞丐版
var newObj = JSON.parse(JSON.stringify(someObj));
```
```js
// 面试够用版
function deepClone(obj) {
    if (obj == null) { return null } 
    if (typeof obj === 'object') {
        // 复杂类型
        let result = obj.constructor === Array : [] : {}
        for (let i in obj) {
            result[i] = typeof obj[i] === 'object' ? deepClone(result[i]) : obj[i]
        }
    } else {
        let result = obj
    }
    return result
}
```

## 实现一个instanceOf

```js
function instanceOf(left, right) {
    let proto = left.__proto__
    let prototype = right.prototype

    while(true) {
        if (proto === null) return false
        if (proto === prototype) return true
        proto = proto.__proto__
    }
}
```

## 数组扁平化
+ 方法1. 使用reduce
```js
const flat = arr => {
    return arr.reduce((pre, cur) => {
        // MDN 二维数组拍平 prev.concat(cur)
        return pre.concat(Array.isArray(cur) ? flat(cur) : cur)
    }, [])
}
```

+ 方法2. 使用函数递归
```js
const flat1 = arr => {
    const res = [];
    const fn = arr => {
        for (let i = 0; i < arr.lengths; i++) {
            if(Array.isArray(arr[i])) {
                fn(arr[i])
            } else {
                res.push(arr[i])
            }
        }
    }
    fn(arr)
    return res
}
```

## 数组去重
```js
const res = Array.from(new Set(arr))

// indexOf
const unique = arr => {
    const res = []
    for (let i = 0; i < arr.length; i++) {
        if (res.indexOf(arr[i]) === -1) res.push(arr[i])
    }
    return res
}
```

### 类数组转化为数组
```js
// 1. Array.from
Array.from(document.querySelectorAll('div'))

// 2. Array.prototype.slice.call()
Array.prototype.slice.call(document.querySelectorAll('div'))

// 3. 扩展运算符
[...document.querySelectorAll('div')]

// 4. Array.prototype.concat.apply
Array.prototype.concat.apply([], document.querySelector('div'))
```

## Array.prototype.filter()

var newArray = arr.filter(callback()[,thisArg])
```js
Array.prototype._filter(callback, thisArg) {
    if (this === undefined) {
        throw new TypeError('this is null or not undefined')
    }
    if (typeof callback !== 'function') {
        throw new TypeError(callback + 'is not a function')
    }

    const res = []
    // 让Obj成为回调函数的对象传递（强制转换对象）
    const Obj = Object(this);
    // >>>0 保证len为number，且为正整数
    const len = Obj.length >>> 0
    for (let i = 0; i < len; i++) {
        if (i in Obj) {
            if (callback.call(thisArg, Obj[i], i, Obj)) {
                res.push(Obj[i])
            }
        }
    }
    return res
}
```

## Array.prototype.map()

```js
Array.prototype._map(callback, thisArg) {
    if (this === undefined) {
        throw new TypeError('')
    }
    if (typeof callback !== 'function') {
        throw new TypeError('')
    }

    const res = []

    const obj = Object(this)
    const len = obj.length >>> 0
    for (let i = 0; i < len; i++) {
        if (i in obj) {
            // 调用回调函数并传入新数组
            res[i] = callback.call(thisArg, ojb[i], i, this)
        }
    }
    return res
}
```

## Array.prototype.forEach()
```js
Array.prototype._forEach(callback, thisArg) {
    if (this === undefined) {
        throw new TypeError('')
    }
    if (typeof callback !== 'function') {
        throw new TypeError('')
    }
    const obj = Object.create(this)
    const len = obj.length >>> 0
    for (let i = 0; i < len; i++) {
        if (i in obj) {
            callback.call(thisArg, obj[i], i, obj)
        }
    }
}
```

## Array.prototype.reduce()
```js
Array.prototype._reduce(callback, initVal) {
    if (this === undefined) {
        throw new TypeError('')
    }

    if (typeof callback !== 'function') {
        throw new TypeError('')
    }

    const obj = Object.create(this)

    const len = obj.length >>> 0

    let accumulator = initVal;
    let k = 0

    // 如果第二个参数是undefined的情况下
    // 则数组的第一个有效值作为累加器的初始值
    if (accumulator === undefined) {
        while (k < len && !(k in obj)) {
            k++
        }
        // 如果超出数组界限，还没找到累加器的初始值，那么则typeError
        if (k >= len) {
            throw new TypeError('')
        }
        accumulator = obj[k++]
    }
    while (k < len) {
        if (k in Obj) {
            accumulator = callback.call(undefined, accumulator, obj[k], k, obj)
        }
        k++
    }
    return accumulator;
}
```

## Function.prototype.apply()

```js
Function.prototype.apply = function (context  = window, args) {
    if (typeof this !== 'function') {
        throw new TypeError('')
    }

    const fn = Symbol('fn')
    context[fn] = this

    const res = context[fn](...args)

    delete context[fn]

    return res;
}
```

## Function.prototype.call()
```js
Function.prototype.call = function (context = window, ...args) {
    if (typeof this !== 'function') {
        throw new TypeError('')
    }

    const fn = Symbol('fn')
    context[fn] = this

    const res = context[fn](...args)
    delete context[fn]

    return res
}
```

## Function.prototype.bind(context, ...args)

```js
Function.prototype.bind = function (context, ...args) {
    if (typeof this !== 'function') {
        throw new TypeError('')
    }

    let self = this

    return function F() {
        // 考虑 new的情况
        if (this instanceof F) {
            return new self(...args, ...argument)
        }
        return self.apply(context, [...args, ...arguments])
    }
}
```

## debounce(防抖动)

```js
const debounce = (fn, await) => {
    let timeout = null;
    return function () {
        clearTimeout(timeout)
        timeout = setTimeout(() => {
            fn.apply(this, arguments)
        }, await)
    }
}
```

## throttle(节流)

```js
const throttle = (fn, await, immediate) => {
    let prev = new Date()
    return function () {
        if (immediate) {
            fn.apply(this, arguments)
        }
        let now = new Date()

        if (now - prev > await) {
            fn.apply(this, arguments)
            prev = new Date()
        }

    }
}
```

## 函数柯里化

```js
function curry (fn, args) {
    let length = fn.length,
        arg = args || []
     
    return function () {
        let newArgs = arg.concat(Array.prototype.slice.call(arguments))

        if (newArgs.length < length) {
            return curry.call(this, fn, newArgs)
        } else {
            return fn.apply(this, newArgs)
        }
    }

}
```

## 模拟new操作
new之后发生3个步骤
1. 以ctor.prototype为原型创建一个对象。
2. 执行构造函数并将this绑定到新创建的对象上
3. 判断构造函数执行返回的结果是否是引用数据类型，若是则返回构造函数执行的结构，否则返回创建的对象。
 
```js
function newOperator(ctor, ...args) {
    if (typeof ctor !== 'function') {
        throw new TypeError('')
    }

    const obj = Object.create(ctor.prototype)
    const res = ctor.apply(obj, args)

    const isObject = typeof res === 'object' && res !== null
    const isFunction = typeof res === 'function'

    return isObject || isFunction ? res : obj
}
```

## instanceof

instanceof 运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上。
```js
const _instanceof = (left, right) => {
    // 基础类型都返回false
    if (typeof left !== 'object' || left === null) return false

    let proto = Object.getPrototypeOf(left)

    while(true) {
        if (proto === null) return false;
        if (proto === right.prototype) return true;
        proto = Object.getPrototypeOf(proto)
    }
}
```

## 原型继承

```js
function Parent(name) {
    this.name = name
}

Parent.prototype.sayName = function () {
    console.log('parent name: ', this.name)
}

function Child(name) {
    Parent.call(this, parentName)
    this.name = name
}

function create(proto) {
    function F() {}
    F.prototype = proto
    return new F()
}

Child.prototype = create(Parent.prototype)
Child.prototype.sayName = function () {
    console.log('child name: ', this.name)
}

Child.prototype.constructor = Child;

var parent = new Parent('father')
parent.sayName()

var child = new Child('son', 'father')
```

## 深拷贝

```js
const cloneDeep = (obj) => {
    if (typeof obj !== 'object' || target === null) {
        return obj
    }

}
```

## Promise 
```js
```

## Promise.all
Promise.all是支持链式调用的，本质上就是返回了一个Promise实例，通过resolve和reject来改变实例状态。
```js
Promise._all = function (promiseArr) {
    return new Promise((resolve, reject) => {
        const ans = []
        let index = 0;
        for (let i  = 0; i < promiseArr.length; i++) {
            promiseArr[i]
            .then(res => {
                ans[i] = res
                index++

                if (index === promiseArr.length) {
                    resolve(ans)
                }
            })
            .catch(err => reject(err))
        }
    })
}
```

## Promise.race
```js
Promise.race = function(promiseArr) {
    return new Promise((resolve, reject) => {
        promiseArr.forEach( p => {
            // 如果不是Promise实例需要转化为Promise实例
            Promise.resolve(p).then(
                val => resolve(val),
                err => reject(err)
            )
        })
    })
}
```

## Promise并行限制
```js
class Scheduler {
    constructor () {
        this.queue = []
        this.maxCount = 2
        this.runCounts = 0
    }

    add (promiseCreator) {
        this.queue.push(promiseCreator)
    }

    taskStart() {
        for (let i = 0; i < this.maxCount; i++) {
            this.request()
        }
    }

    request () {
        if (!this.queue || !this.queue.length || this.runCounts >= this.maxCount) {
            return
        }
        this.runCount++

        this.queue.shift()().then(() => {
            this.runCounts--;
            this.request();
        })
    }

}
```

## JSONP

## AJAX
```js
const getJson = function(url) {
    return new Promise((resolve, reject) => {
        const xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHttp');

        xhr.open('GET', url, false)
        xhr.setRequestHeader('Accept', 'application/json')
        xhr.onreadystatechange = function () {
            if (xhr.readyState !== 4) return
            if (xhr.status === 200 || xhr.status === 304){
                resolve(xhr.responseText)
            } else {
                reject(new Error(xhr.responseText))
            }
        }
        xhr.send()
    })
}
```

## event模块
实现node中的回调函数的机制，node中回调函数其实是内部使用了观察者模式。

观察者模式：定义了对象间一种一对多的依赖关系，当目标对象Subject发生改变时，所有依赖它的对象Observer都会得到通知；
```js
function EventEmitter() {
    this.events = new Map();
}
// 需要实现的一些方法
// addListener, removeListener, once, removeAllListeners, emit等
// 包装回调
const wrapCallback = (fn, once = false) => ({callback: fn, once})

// 模拟实现addListener
EventEmitter.prototype.addListener = function(type, fn, once = false) {
    const handler = this.events.get(type)

    if(!handler) {
        // 没有type绑定事件
        this.events.set(type, wrapCallback(fn, once))
    } else if (handler && typeof handler.callback === 'function') {
        // 目前type事件只有一个回调
        this.events.set(type, [handler, wrapCallback(fn, once)])
    } else {
        // 目前type事件数>=2
        handler.push(wrapCallback(fn, once))
    }
}

// 模拟实现removeListener
EventEmitter.prototype.removeListener = function(type, listener) {
    const handler = this.events.get(type)

    if (!handler) return
    
    if (!Array.isArray(handler)) {
        if(handler.callback === listener.callback) this.event.delete(type)
        else return
    }

    for (let i = 0; i < handler.length; i++) {
        const item = handler[i]

        if (item.callback === listener.callback) {
            handler.splice(i, 1)
            i--

            if(handler.length === 1) {
                this.events.set(type, handler[0])
            }
        }
    }
}

// 实现once方法
EventEmitter.prototype.once = function (type, listener) {
    this.addListener(type, listener, true)
}

// 模拟实现emit方法
EventEmitter.prototype.emit = function(type, ...args) {
    const handler = this.events.get(type)

    if (!handler) return

    if (Array.isArray(handler)) {
        handler.forEach(item => {
            item.callback.apply(this, args)
            if (item.once) {
                this.removeListener(type, item)
            }
        })
    } else {
        handler.callback.apply(this, args)
        if (handler.once) {
            this.evnets.delete(type)
        }
    }

    return true
}

// 实现removeALl
EventEmitter.prototype.removeAllListeners = function(type) {
    const handler = this.events.get(type)
    if (!handler) return
    this.events.delete(type)
}
```






